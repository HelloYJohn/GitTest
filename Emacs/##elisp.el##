* function and variable
(defun NAME ARGLIST [DOCSTRING] BODY...)
(defvar SYMBOL &optional INITVALUE DOCSTRING)
(setq SYM VAL SYM VAL ...)
(let VARLIST BODY...)
(let* VARLIST BODY...)
(lambda ARGS [DOCSTRING] [INTERACTIVE] BODY)
(progn BODY ...)
(if COND THEN ELSE...)
(cond CLAUSES...)
(when COND BODY ...)
(unless COND BODY ...)
(when COND BODY ...)
(or CONDITIONS ...)
(and CONDITIONS ...)
(not OBJECT)

* number
;; 测试函数
(integerp OBJECT)
(floatp OBJECT)
(numberp OBJECT)
(zerop NUMBER)
(wholenump OBJECT)
;; 比较函数
(> NUM1 NUM2)
(< NUM1 NUM2)
(>= NUM1 NUM2)
(<= NUM1 NUM2)
(= NUM1 NUM2)
(eql OBJ1 OBJ2)
(/= NUM1 NUM2)
;; 转换函数
(float ARG)
(truncate ARG &optional DIVISOR)
(floor ARG &optional DIVISOR)
(ceiling ARG &optional DIVISOR)
(round ARG &optional DIVISOR)
;; 运算
(+ &rest NUMBERS-OR-MARKERS)
(- &optional NUMBER-OR-MARKER &rest MORE-NUMBERS-OR-MARKERS)
(* &rest NUMBERS-OR-MARKERS)
(/ DIVIDEND DIVISOR &rest DIVISORS)
(1+ NUMBER)
(1- NUMBER)
(abs ARG)
(% X Y)
(mod X Y)
(sin ARG)
(cos ARG)
(tan ARG)
(asin ARG)
(acos ARG)
(atan Y &optional X)
(sqrt ARG)
(exp ARG)
(expt ARG1 ARG2)
(log ARG &optional BASE)
(log10 ARG)
(logb ARG)
;; 随机数
(random &optional N)

* string
;; 测试函数
(stringp OBJECT)
(string-or-null-p OBJECT)
(char-or-string-p OBJECT)
;; 构建函数
(make-string LENGTH INIT)
(string &rest CHARACTERS)
(substring STRING FROM &optional TO)
(concat &rest SEQUENCES)
;; 比较函数
(char-equal C1 C2)
(string= S1 S2)
(string-equal S1 S2)
(string< S1 S2)
;; 转换函数
(char-to-string CHAR)
(string-to-char STRING)
(number-to-string NUMBER)
(string-to-number STRING &optional BASE)
(downcase OBJ)
(upcase OBJ)
(capitalize OBJ)
(upcase-initials OBJ)
(format STRING &rest OBJECTS)
;; 查找与替换
(string-match REGEXP STRING &optional START)
(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)
(replace-regexp-in-string REGEXP REP STRING &optional FIXEDCASE LITERAL SUBEXP START)
(subst-char-in-string FROMCHAR TOCHAR STRING &optional INPLACE)

* cons cell and list
'(1 . 2)
'(?a . 1)
'(1 . "a")
'(1 . nil)
'(nil . nil)
(read "(1 . 2)")
(consp '(1 . 2))
(consp '(1 . (2 . nil)))
(consp nil)
(listp '(1 . 2))
(listp nil)
'(1 . (2 . (3 . nil)))
(cons 1 2)
(cons 1 '())
'()
(setq foo '(a b))
(cons 'x foo)
(push 'x foo)
foo

(list 1 2 3)
'((+ 1 2) 3)
(list (+ 1 2) 3)
(setq foo '(1 2 3))
(setcar foo 'a)
foo
(setcar (cdr foo) 'b)
foo
(setcar (nthcdr 2 foo) 'c)
foo
(setq foo nil)
foo
(push 'a foo)
foo
(push 'b foo)
foo
(pop foo)
foo
(setq foo '(a b c))
(reverse foo)
(setq foo '(a b c))
(remq 'b foo)
(delq 'b foo)
foo
(delq 'a foo)
foo
(assoc "a" '(("a" 97) ("b" 98)))
(assq 'a '((a . 97) (b . 98)))
(rassoc '(97) '(("a" 97) ("b" 98)))
(reas)
(dolist (foo '(1 2 3))
  (incf foo))
foo
(setq bar nil)
(dolist (foo '(1 2 3) bar)
  (push (incf foo) bar))

(defun my-remove-if (predicate list)
  (delq nil (mapcar (lambda (n)
                      (and (not (funcall predicate n)) n))
                    list)))

(defun evenp (n)
  (= (% n 2) 0)
  )
(my-remove-if 'evenp '(0 1 2 3 4 5))